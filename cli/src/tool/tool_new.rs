use {
    crate::{command_title, display::json_output, loading, prelude::*},
    convert_case::{Case, Casing},
    minijinja::{context, Environment},
    tokio::{
        fs::{create_dir_all, File},
        io::AsyncWriteExt,
    },
};

/// Available templates for tool generation.
#[derive(Clone, Debug, ValueEnum)]
pub(crate) enum ToolTemplate {
    Rust,
    Move,
}

impl ToolTemplate {
    /// For each template, transform the template based on the given variables
    /// and return the files to write.
    pub(crate) fn transform(&self, name: &str) -> AnyResult<Vec<(String, Option<String>)>> {
        match self {
            ToolTemplate::Rust => {
                let name_kebab_case = name.to_case(Case::Kebab);
                let name_pascal_case = name.to_case(Case::Pascal);

                let mut env = Environment::new();

                env.add_template("main", include_str!("templates/rust/main.rs.jinja"))?;
                env.add_template("cargo", include_str!("templates/rust/Cargo.toml.jinja"))?;

                let main_template = env.get_template("main")?;
                let cargo_template = env.get_template("cargo")?;

                Ok(vec![
                    ("src".to_string(), None),
                    (
                        "src/main.rs".to_string(),
                        Some(main_template.render(context! { name_kebab_case, name_pascal_case })?),
                    ),
                    (
                        "Cargo.toml".to_string(),
                        Some(
                            cargo_template
                                .render(context! { name_kebab_case, name_pascal_case })?,
                        ),
                    ),
                ])
            }
            ToolTemplate::Move => {
                let name_snake_case = name.to_case(Case::Snake);
                let name_pascal_case = name.to_case(Case::Pascal);
                let name_uppercase = name.to_case(Case::UpperSnake);

                let mut env = Environment::new();

                env.add_template("move_toml", include_str!("templates/move/Move.toml.jinja"))?;
                env.add_template("tool_move", include_str!("templates/move/tool.move.jinja"))?;
                env.add_template(
                    "tests_move",
                    include_str!("templates/move/tests.move.jinja"),
                )?;
                env.add_template("gitignore", include_str!("templates/move/.gitignore.jinja"))?;

                let move_toml_template = env.get_template("move_toml")?;
                let tool_move_template = env.get_template("tool_move")?;
                let tests_move_template = env.get_template("tests_move")?;
                let gitignore_template = env.get_template("gitignore")?;

                Ok(vec![
                    ("sources".to_string(), None),
                    ("tests".to_string(), None),
                    (
                        "Move.toml".to_string(),
                        Some(move_toml_template.render(context! { name_snake_case })?),
                    ),
                    (
                        format!("sources/{name_snake_case}.move"),
                        Some(tool_move_template.render(
                            context! { name_snake_case, name_pascal_case, name_uppercase },
                        )?),
                    ),
                    (
                        format!("tests/{name_snake_case}_tests.move"),
                        Some(tests_move_template.render(context! { name_snake_case })?),
                    ),
                    (
                        ".gitignore".to_string(),
                        Some(gitignore_template.render(context! {})?),
                    ),
                ])
            }
        }
    }
}

/// Create a new tool based on the provided name and template.
pub(crate) async fn create_new_tool(
    name: String,
    template: ToolTemplate,
    target: PathBuf,
) -> AnyResult<(), NexusCliError> {
    command_title!(
        "Creating a new Nexus Tool '{name}' with template '{template:?}' in '{target}'",
        target = target.display()
    );

    let transforming_template = loading!("Transforming template...");

    let files = match template.transform(&name) {
        Ok(files) => files,
        Err(e) => {
            transforming_template.error();

            return Err(NexusCliError::Any(e));
        }
    };

    transforming_template.success();

    // Write each file that was generated by the template.
    let writing_file = loading!("Writing template files...");

    // Create the tool's root directory.
    let root_directory = target.join(&name);

    if let Err(e) = create_dir_all(&root_directory).await {
        writing_file.error();

        return Err(NexusCliError::Io(e));
    };

    for (path, content) in files {
        let path = target.join(&name).join(&path);

        // Check if we need to create a directory.
        let content = match content {
            Some(content) => content,
            None => {
                if let Err(e) = create_dir_all(path).await {
                    writing_file.error();

                    return Err(NexusCliError::Io(e));
                }

                continue;
            }
        };

        let mut file = match File::create(path).await {
            Ok(file) => file,
            Err(e) => {
                writing_file.error();

                return Err(NexusCliError::Io(e));
            }
        };

        if let Err(e) = file.write_all(content.as_bytes()).await {
            writing_file.error();

            return Err(NexusCliError::Io(e));
        }
    }

    writing_file.success();

    json_output(&json!({
        "path": root_directory,
    }))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use {super::*, assert_matches::assert_matches};

    #[tokio::test]
    async fn test_create_new_tool() {
        let tempdir = tempfile::tempdir().unwrap().into_path();

        let result = create_new_tool("test".to_string(), ToolTemplate::Rust, tempdir.clone()).await;

        assert_matches!(result, Ok(()));

        // Check that main file was written with the correct contents.
        let path = tempdir.join("test/src/main.rs");
        let contents = tokio::fs::read_to_string(path).await.unwrap();

        assert!(contents.contains("enum Output {\n    Ok {\n        // Add output ports for the `Ok` variant\n    },\n    Err {\n        reason: String,\n        code: Option<u16>\n    },\n}"));
        assert!(contents.contains("    async fn new() -> Self {\n        Self\n    }"));
        assert!(contents.contains("    fn fqn() -> ToolFqn {\n        // The fully qualified name of the tool.\n\n        fqn!(\"domain.author.test@1\")\n    }"));
        assert!(contents.contains("    fn path() -> &'static str {\n        \"\"\n    }"));
        assert!(contents.contains("struct Test;"));
        assert!(contents.contains("impl NexusTool for Test {"));

        // Check that manifest file was written with the correct contents.
        let path = tempdir.join("test/Cargo.toml");
        let contents = tokio::fs::read_to_string(path).await.unwrap();

        assert!(contents.contains(r#"name = "test""#));
        assert!(contents.contains("[dependencies.nexus-toolkit]"));
    }

    #[tokio::test]
    async fn test_create_new_move_tool() {
        let tempdir = tempfile::tempdir().unwrap().into_path();

        let result =
            create_new_tool("test_tool".to_string(), ToolTemplate::Move, tempdir.clone()).await;

        assert_matches!(result, Ok(()));

        // Check that directories were created.
        let sources_dir = tempdir.join("test_tool/sources");
        assert!(sources_dir.exists());

        let tests_dir = tempdir.join("test_tool/tests");
        assert!(tests_dir.exists());

        // Check that Move.toml was written with correct contents.
        let move_toml_path = tempdir.join("test_tool/Move.toml");
        let move_toml_contents = tokio::fs::read_to_string(move_toml_path).await.unwrap();

        assert!(move_toml_contents.contains(r#"name = "test_tool""#));
        assert!(move_toml_contents.contains("edition = \"2024.beta\""));
        assert!(move_toml_contents.contains("nexus_primitives"));
        assert!(move_toml_contents.contains("nexus_workflow"));
        assert!(move_toml_contents.contains("nexus_interface"));

        // Check that the main Move file was written with correct contents.
        let move_file_path = tempdir.join("test_tool/sources/test_tool.move");
        let move_contents = tokio::fs::read_to_string(move_file_path).await.unwrap();

        assert!(move_contents.contains("module test_tool::test_tool;"));
        assert!(move_contents.contains("public struct TEST_TOOL has drop {}"));
        assert!(move_contents.contains("public struct TestToolWitness has key, store"));
        assert!(move_contents.contains("public struct TestToolState has key"));
        assert!(move_contents.contains("public enum Output"));
        assert!(move_contents.contains("fun init(_otw: TEST_TOOL, ctx: &mut TxContext)"));
        assert!(move_contents.contains("public fun execute("));
        assert!(move_contents.contains("worksheet: &mut ProofOfUID"));
        assert!(move_contents.contains("): ToolOutput"));
        assert!(move_contents.contains("public fun witness_id(self: &TestToolState): ID"));
        assert!(
            move_contents.contains("public fun init_for_test(otw: TEST_TOOL, ctx: &mut TxContext)")
        );

        // Check that the test file was written.
        let test_file_path = tempdir.join("test_tool/tests/test_tool_tests.move");
        let test_contents = tokio::fs::read_to_string(test_file_path).await.unwrap();

        assert!(test_contents.contains("module test_tool::test_tool_tests;"));
        assert!(test_contents.contains("fun test_test_tool()"));

        // Check that .gitignore was written.
        let gitignore_path = tempdir.join("test_tool/.gitignore");
        let gitignore_contents = tokio::fs::read_to_string(gitignore_path).await.unwrap();

        assert!(gitignore_contents.contains("build/*"));
    }
}
