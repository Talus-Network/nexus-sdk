use {
    crate::{
        command_title, display::json_output, loading, notify_error, notify_success, prelude::*,
        sui::*,
    },
    nexus_sdk::{
        idents::{primitives, workflow},
        sui,
        transactions::tool,
    },
    serde_json::{json, Map, Value},
};

/// Register a new onchain tool with automatic schema generation.
/// The input schema is automatically generated by introspecting the Move module's "execute" function.
/// todo: merge this function with the existing `tool_register.rs` function.
/// https://github.com/Talus-Network/nexus/issues/501
pub(crate) async fn register_onchain_tool(
    package_address: sui::ObjectID,
    module_name: String,
    fqn: ToolFqn,
    description: String,
    witness_id: sui::ObjectID,
    no_save: bool,
    sui_gas_coin: Option<sui::ObjectID>,
    sui_gas_budget: u64,
) -> AnyResult<(), NexusCliError> {
    command_title!(
        "Registering Onchain Tool '{fqn}' from package '{package_address}'",
        fqn = fqn,
        package_address = package_address
    );

    // Load CLI configuration.
    let mut conf = CliConf::load().await.unwrap_or_default();

    // Nexus objects must be present in the configuration.
    let objects = &get_nexus_objects(&mut conf).await?;

    // Create wallet context, Sui client and find the active address.
    let mut wallet = create_wallet_context(&conf.sui.wallet_path, conf.sui.net).await?;
    let sui = build_sui_client(&conf.sui).await?;
    let address = wallet.active_address().map_err(NexusCliError::Any)?;

    // Fetch gas coin object.
    let gas_coin = fetch_gas_coin(&sui, address, sui_gas_coin).await?;

    // Fetch reference gas price.
    let reference_gas_price = fetch_reference_gas_price(&sui).await?;

    // Generate input schema by introspecting the Move module's "execute" function.
    notify_success!("Auto-generating input schema from Move module...");
    let base_input_schema =
        match generate_input_schema(&sui, package_address, &module_name, "execute").await {
            Ok(schema) => {
                notify_success!(
                    "Generated base input schema: {}",
                    schema.truecolor(100, 255, 100)
                );
                schema
            }
            Err(e) => {
                notify_error!(
                    "Failed to generate input schema for tool '{fqn}': {error}",
                    fqn = fqn.to_string().truecolor(100, 100, 100),
                    error = e
                );
                return Err(e);
            }
        };

    // Generate output schema by introspecting the Move module's "Output" enum.
    notify_success!("Auto-generating output schema from Move module...");
    let base_output_schema =
        match generate_output_schema(&sui, package_address, &module_name, "Output").await {
            Ok(schema) => {
                notify_success!(
                    "Generated base output schema: {}",
                    schema.truecolor(100, 255, 100)
                );
                schema
            }
            Err(e) => {
                notify_error!(
                    "Failed to generate output schema for tool '{fqn}': {error}",
                    fqn = fqn.to_string().truecolor(100, 100, 100),
                    error = e
                );
                return Err(e);
            }
        };

    // Allow user to customize parameter descriptions.
    let input_schema = match customize_parameter_descriptions(base_input_schema) {
        Ok(schema) => {
            notify_success!("Input parameter descriptions customized successfully!");
            schema
        }
        Err(e) => {
            notify_error!("Failed to customize input parameter descriptions: {}", e);
            return Err(e);
        }
    };

    // Allow user to customize output variant and field descriptions.
    let output_schema = match customize_output_variant_and_field_descriptions(base_output_schema) {
        Ok(schema) => {
            notify_success!("Output variant and field descriptions customized successfully!");
            schema
        }
        Err(e) => {
            notify_error!(
                "Failed to customize output variant and field descriptions: {}",
                e
            );
            return Err(e);
        }
    };

    // Craft a TX to register the tool.
    let tx_handle = loading!("Crafting transaction...");

    let mut tx = sui::ProgrammableTransactionBuilder::new();

    if let Err(e) = tool::register_on_chain_for_self(
        &mut tx,
        objects,
        package_address,
        module_name.clone(),
        input_schema.clone(),
        output_schema.clone(),
        &fqn,
        description.clone(),
        witness_id,
        address.into(),
    ) {
        tx_handle.error();

        return Err(NexusCliError::Any(e));
    }

    tx_handle.success();

    let tx_data = sui::TransactionData::new_programmable(
        address,
        vec![gas_coin.object_ref()],
        tx.finish(),
        sui_gas_budget,
        reference_gas_price,
    );

    // Sign and submit the TX.
    let response = match sign_and_execute_transaction(&sui, &wallet, tx_data).await {
        Ok(response) => response,
        // If the tool is already registered, we don't want to fail the
        // command.
        Err(NexusCliError::Any(e)) if e.to_string().contains("register_on_chain_tool_") => {
            notify_error!(
                "Tool '{fqn}' is already registered.",
                fqn = fqn.to_string().truecolor(100, 100, 100)
            );

            json_output(&json!({
                "tool_fqn": fqn,
                "already_registered": true,
            }))?;

            return Ok(());
        }
        // Any other error fails the tool registration.
        Err(e) => {
            notify_error!(
                "Failed to register tool '{fqn}': {error}",
                fqn = fqn.to_string().truecolor(100, 100, 100),
                error = e
            );

            return Err(e);
        }
    };

    // Parse the owner cap object IDs from the response.
    let owner_caps = response
        .object_changes
        .unwrap_or_default()
        .into_iter()
        .filter_map(|change| match change {
            sui::ObjectChange::Created {
                object_type,
                object_id,
                ..
            } if object_type.address == *objects.primitives_pkg_id
                && object_type.module
                    == primitives::OwnerCap::CLONEABLE_OWNER_CAP.module.into()
                && object_type.name == primitives::OwnerCap::CLONEABLE_OWNER_CAP.name.into() =>
            {
                Some((object_id, object_type))
            }
            _ => None,
        })
        .collect::<Vec<_>>();

    // Find `CloneableOwnerCap<OverTool>` object ID.
    let over_tool = owner_caps.iter().find_map(|(object_id, object_type)| {
        match object_type.type_params.first() {
            Some(sui::MoveTypeTag::Struct(what_for))
                if what_for.module == workflow::ToolRegistry::OVER_TOOL.module.into()
                    && what_for.name == workflow::ToolRegistry::OVER_TOOL.name.into() =>
            {
                Some(object_id)
            }
            _ => None,
        }
    });

    let Some(over_tool_id) = over_tool else {
        return Err(NexusCliError::Any(anyhow!(
            "Could not find the OwnerCap<OverTool> object ID in the transaction response."
        )));
    };

    notify_success!(
        "OwnerCap<OverTool> object ID: {id}",
        id = over_tool_id.to_string().truecolor(100, 100, 100)
    );

    // Note: Onchain tools don't create OverGas caps, so we only save the OverTool cap
    notify_success!("Onchain tools use a different gas model. No OverGas cap was created.");

    // Save the owner caps to the CLI conf.
    if !no_save {
        let save_handle = loading!("Saving the owner cap to the CLI configuration...");

        let mut conf = CliConf::load().await.unwrap_or_default();

        // For onchain tools, we only have OverTool cap, use a placeholder for OverGas
        // TODO: Update ToolOwnerCaps structure to support onchain tools?
        conf.tools.insert(
            fqn.clone(),
            ToolOwnerCaps {
                over_tool: *over_tool_id,
                over_gas: sui::ObjectID::ZERO, // Placeholder
            },
        );

        if let Err(e) = conf.save().await {
            save_handle.error();

            return Err(NexusCliError::Any(e));
        }

        save_handle.success();
    }

    json_output(&json!({
        "digest": response.digest,
        "tool_fqn": fqn,
        "package_address": package_address.to_string(),
        "module_name": module_name,
        "witness_id": witness_id.to_string(),
        "description": description,
        "input_schema": input_schema,
        "output_schema": output_schema,
        "owner_cap_over_tool_id": over_tool_id,
        "owner_cap_over_gas_id": null,
        "already_registered": false,
    }))?;

    Ok(())
}

/// Generate input schema by introspecting the Move module's execute function.
async fn generate_input_schema(
    sui: &sui::Client,
    package_address: sui::ObjectID,
    module_name: &str,
    execute_function: &str,
) -> AnyResult<String, NexusCliError> {
    let fetching_handle = loading!("Fetching Move module information...");

    // Fetch all normalized Move modules for the package.
    let all_modules = match sui
        .read_api()
        .get_normalized_move_modules_by_package(package_address)
        .await
    {
        Ok(modules) => {
            fetching_handle.success();
            modules
        }
        Err(e) => {
            fetching_handle.error();
            return Err(NexusCliError::Any(anyhow!(
                "Failed to fetch Move modules for package {}: {}",
                package_address,
                e
            )));
        }
    };

    // Find the specific module.
    let normalized_module = all_modules.get(module_name).ok_or_else(|| {
        NexusCliError::Any(anyhow!(
            "Module '{}' not found in package '{}'",
            module_name,
            package_address
        ))
    })?;

    let parsing_handle = loading!("Parsing execute function signature...");

    // Find the execute function.
    let execute_func = normalized_module
        .exposed_functions
        .get(execute_function)
        .ok_or_else(|| {
            NexusCliError::Any(anyhow!(
                "Function '{}' not found in module '{}'",
                execute_function,
                module_name
            ))
        })?;

    // Parse function parameters.
    let mut schema_map = Map::new();
    let mut param_index = 0;

    for (i, param_type) in execute_func.parameters.iter().enumerate() {
        let is_tx_context = is_tx_context_param(param_type);
        println!(
            "DEBUG: Parameter {}: type={:?}, is_tx_context={}",
            i, param_type, is_tx_context
        );

        // Skip the first parameter (Promise/ProofOfUID) and the last parameter (TxContext).
        if i == 0 || is_tx_context {
            continue;
        }

        let param_schema = convert_move_type_to_schema(param_type)?;

        // Store parameter information with index as the default name.
        let mut param_obj = match param_schema {
            Value::Object(obj) => obj,
            other => {
                let mut new_obj = Map::new();
                new_obj.insert("type".to_string(), other);
                new_obj
            }
        };

        // Add metadata for parameter customization.
        param_obj.insert(
            "parameter_index".to_string(),
            Value::Number(param_index.into()),
        );
        param_obj.insert("custom_name".to_string(), Value::Null);

        schema_map.insert(param_index.to_string(), Value::Object(param_obj));
        param_index += 1;
    }

    parsing_handle.success();

    let schema_json = Value::Object(schema_map);
    let schema_string = serde_json::to_string(&schema_json)
        .map_err(|e| NexusCliError::Any(anyhow!("Failed to serialize schema: {}", e)))?;

    Ok(schema_string)
}

/// Convert a Sui Move normalized type to a JSON schema representation.
/// todo: check for all types and add test.
/// https://github.com/Talus-Network/nexus/issues/502
fn convert_move_type_to_schema(
    move_type: &sui::MoveNormalizedType,
) -> AnyResult<Value, NexusCliError> {
    use sui::MoveNormalizedType;

    match move_type {
        MoveNormalizedType::Bool => Ok(json!({
            "type": "bool",
            "description": "Boolean value"
        })),
        MoveNormalizedType::U8 => Ok(json!({
            "type": "u8",
            "description": "8-bit unsigned integer"
        })),
        MoveNormalizedType::U16 => Ok(json!({
            "type": "u16",
            "description": "16-bit unsigned integer"
        })),
        MoveNormalizedType::U32 => Ok(json!({
            "type": "u32",
            "description": "32-bit unsigned integer"
        })),
        MoveNormalizedType::U64 => Ok(json!({
            "type": "u64",
            "description": "64-bit unsigned integer"
        })),
        MoveNormalizedType::U128 => Ok(json!({
            "type": "u128",
            "description": "128-bit unsigned integer"
        })),
        MoveNormalizedType::U256 => Ok(json!({
            "type": "u256",
            "description": "256-bit unsigned integer"
        })),
        MoveNormalizedType::Address => Ok(json!({
            "type": "address",
            "description": "Sui address"
        })),
        MoveNormalizedType::Signer => Ok(json!({
            "type": "signer",
            "description": "Transaction signer"
        })),
        MoveNormalizedType::Vector(inner_type) => {
            let inner_schema = convert_move_type_to_schema(inner_type)?;
            Ok(json!({
                "type": "vector",
                "description": "Vector of values",
                "element_type": inner_schema
            }))
        }
        MoveNormalizedType::Struct {
            address,
            module,
            name,
            type_arguments: _,
        } => {
            if address == &sui::FRAMEWORK_PACKAGE_ID.to_string() {
                match (module.as_str(), name.as_str()) {
                    ("object", "ID") => Ok(json!({
                        "type": "object_id",
                        "description": "Sui object ID"
                    })),
                    ("object", "UID") => Ok(json!({
                        "type": "object_id",
                        "description": "Unique identifier for an object"
                    })),
                    ("coin", "Coin") => Ok(json!({
                        "type": "object",
                        "description": "Coin object reference"
                    })),
                    ("tx_context", "TxContext") => Ok(json!({
                        "type": "tx_context",
                        "description": "Transaction context (automatically provided)"
                    })),
                    _ => Ok(json!({
                        "type": "object",
                        "description": format!("{}::{}", module, name)
                    })),
                }
            } else if address == "0x1" {
                // Handle standard library types.
                match (module.as_str(), name.as_str()) {
                    ("string", "String") => Ok(json!({
                        "type": "string",
                        "description": "UTF-8 string"
                    })),
                    ("ascii", "String") => Ok(json!({
                        "type": "string",
                        "description": "ASCII string"
                    })),
                    _ => Ok(json!({
                        "type": "object",
                        "description": format!("{}::{}::{}", address, module, name)
                    })),
                }
            } else {
                // Custom struct types are treated as object references.
                Ok(json!({
                    "type": "object",
                    "description": format!("{}::{}::{}", address, module, name)
                }))
            }
        }
        MoveNormalizedType::Reference(inner_type) => {
            let inner_schema = convert_move_type_to_schema(inner_type)?;
            Ok(json!({
                "type": "reference",
                "description": "Reference to an object",
                "referenced_type": inner_schema
            }))
        }
        MoveNormalizedType::MutableReference(inner_type) => {
            let inner_schema = convert_move_type_to_schema(inner_type)?;
            if let Value::Object(mut schema_obj) = inner_schema {
                schema_obj.insert("mutable".to_string(), Value::Bool(true));
                Ok(Value::Object(schema_obj))
            } else {
                Ok(json!({
                    "type": "mutable_reference",
                    "description": "Mutable reference to an object",
                    "referenced_type": inner_schema
                }))
            }
        }
        MoveNormalizedType::TypeParameter(_) => Ok(json!({
            "type": "generic",
            "description": "Generic type parameter"
        })),
    }
}

/// Check if a parameter is TxContext (should be excluded from schema).
fn is_tx_context_param(move_type: &sui::MoveNormalizedType) -> bool {
    use sui::MoveNormalizedType;

    match move_type {
        MoveNormalizedType::Struct {
            address,
            module,
            name,
            ..
        } => {
            // TxContext
            (address == "0x2" || address == &sui::FRAMEWORK_PACKAGE_ID.to_string())
                && module == "tx_context"
                && name == "TxContext"
        }
        MoveNormalizedType::MutableReference(inner_type) => {
            // &mut TxContext
            if let MoveNormalizedType::Struct {
                address,
                module,
                name,
                ..
            } = inner_type.as_ref()
            {
                (address == "0x2" || address == &sui::FRAMEWORK_PACKAGE_ID.to_string())
                    && module == "tx_context"
                    && name == "TxContext"
            } else {
                false
            }
        }
        MoveNormalizedType::Reference(inner_type) => {
            // &TxContext
            if let MoveNormalizedType::Struct {
                address,
                module,
                name,
                ..
            } = inner_type.as_ref()
            {
                (address == "0x2" || address == &sui::FRAMEWORK_PACKAGE_ID.to_string())
                    && module == "tx_context"
                    && name == "TxContext"
            } else {
                false
            }
        }
        _ => false,
    }
}

/// Allow the user to customize parameter descriptions interactively.
fn customize_parameter_descriptions(schema_json: String) -> AnyResult<String, NexusCliError> {
    use serde_json::{Map, Value};
    use std::io::{self, Write};

    // Skip interactive prompts in JSON mode.
    if JSON_MODE.load(Ordering::Relaxed) {
        return Ok(schema_json);
    }

    // Parse the schema.
    let mut schema: Map<String, Value> = serde_json::from_str(&schema_json)
        .map_err(|e| NexusCliError::Any(anyhow::anyhow!("Failed to parse schema JSON: {}", e)))?;

    if schema.is_empty() {
        println!(
            "\n{info} No parameters to customize.",
            info = "▶".cyan().bold()
        );
        return Ok(schema_json);
    }

    println!(
        "\n{title}",
        title = "Input Schema Customization".bold().cyan()
    );
    println!(
        "Customize names and descriptions for each input parameter (press Enter to keep current)"
    );

    // Sort parameter keys to ensure consistent order.
    let mut param_keys: Vec<String> = schema.keys().cloned().collect();
    param_keys.sort_by(|a, b| {
        let a_num: i32 = a.parse().unwrap_or(i32::MAX);
        let b_num: i32 = b.parse().unwrap_or(i32::MAX);
        a_num.cmp(&b_num)
    });

    for param_key in param_keys {
        if let Some(param_obj) = schema.get_mut(&param_key) {
            if let Some(param_map) = param_obj.as_object_mut() {
                let param_type = param_map
                    .get("type")
                    .and_then(|v| v.as_str())
                    .unwrap_or("unknown");

                let current_description = param_map
                    .get("description")
                    .and_then(|v| v.as_str())
                    .unwrap_or("No description")
                    .to_string();

                // The default name is the parameter index (0, 1, 2, etc.)
                let default_name = param_key.clone();

                let current_custom_name = param_map
                    .get("custom_name")
                    .and_then(|v| v.as_str())
                    .map(|s| s.to_string());

                let is_mutable = param_map
                    .get("mutable")
                    .and_then(|v| v.as_bool())
                    .unwrap_or(false);

                let type_display = if is_mutable {
                    format!("&mut {}", param_type)
                } else {
                    param_type.to_string()
                };

                println!(" ");
                println!(
                    "{} Parameter {}: {} {}",
                    "▶".purple().bold(),
                    param_key.bold(),
                    type_display.blue().bold(),
                    if is_mutable {
                        "(mutable)".yellow()
                    } else {
                        "".normal()
                    }
                );

                // Customize parameter name.
                println!("Current name: {}", default_name.truecolor(150, 150, 150));
                if let Some(ref custom_name) = current_custom_name {
                    println!("Current custom name: {}", custom_name.green());
                }
                print!("Custom name (Enter to keep '{}'): ", default_name);
                io::stdout().flush().unwrap();

                let mut name_input = String::new();
                io::stdin().read_line(&mut name_input).unwrap();
                let custom_name = name_input.trim();

                if !custom_name.is_empty() {
                    param_map.insert(
                        "custom_name".to_string(),
                        Value::String(custom_name.to_string()),
                    );
                    println!(
                        "{} Updated parameter name to: {}",
                        "✓".green().bold(),
                        custom_name.green().bold()
                    );
                } else {
                    // Clear any existing custom name to use the default (integer index).
                    if current_custom_name.is_some() {
                        param_map.insert("custom_name".to_string(), Value::Null);
                    }
                    println!(
                        "{} Using default name: {}",
                        "→".truecolor(150, 150, 150),
                        default_name.truecolor(150, 150, 150)
                    );
                }

                // Customize parameter description.
                println!(
                    "Current description: {}",
                    current_description.truecolor(150, 150, 150)
                );
                print!("Custom description (Enter to keep): ");
                io::stdout().flush().unwrap();

                let mut desc_input = String::new();
                io::stdin().read_line(&mut desc_input).unwrap();
                let custom_description = desc_input.trim();

                if !custom_description.is_empty() {
                    param_map.insert(
                        "description".to_string(),
                        Value::String(custom_description.to_string()),
                    );
                    println!("{} Updated description", "✓".green().bold());
                } else {
                    println!("{} Kept current description", "→".truecolor(150, 150, 150));
                }
            }
        }
    }

    println!(" ");

    // Convert the schema to use custom names as keys if provided.
    let final_schema = convert_schema_to_named_ports(schema)?;

    // Convert back to JSON string.
    serde_json::to_string(&final_schema)
        .map_err(|e| NexusCliError::Any(anyhow::anyhow!("Failed to serialize schema: {}", e)))
}

/// Convert schema from integer keys to custom parameter names.
fn convert_schema_to_named_ports(
    schema: Map<String, Value>,
) -> AnyResult<Map<String, Value>, NexusCliError> {
    let mut final_schema = Map::new();

    for (param_index, param_value) in schema {
        if let Some(param_obj) = param_value.as_object() {
            // Create a clean parameter schema without the metadata.
            let mut clean_param = param_obj.clone();
            clean_param.remove("parameter_index");
            clean_param.remove("custom_name");

            // Use custom name if provided, otherwise use the integer index.
            if let Some(custom_name) = param_obj.get("custom_name").and_then(|v| v.as_str()) {
                final_schema.insert(custom_name.to_string(), Value::Object(clean_param));
            } else {
                // If no custom name, use the integer index.
                final_schema.insert(param_index, Value::Object(clean_param));
            }
        } else {
            // Means something went wrong.
            return Err(NexusCliError::Any(anyhow!(
                "Parameter value is not an object."
            )));
        }
    }

    Ok(final_schema)
}

/// Generate output schema by introspecting the Move module's `Output`` enum.
async fn generate_output_schema(
    sui: &sui::Client,
    package_address: sui::ObjectID,
    module_name: &str,
    output_enum_name: &str,
) -> AnyResult<String, NexusCliError> {
    let fetching_handle = loading!("Fetching Move module information for output schema...");

    // Fetch all normalized Move modules for the package.
    let all_modules = match sui
        .read_api()
        .get_normalized_move_modules_by_package(package_address)
        .await
    {
        Ok(modules) => {
            fetching_handle.success();
            modules
        }
        Err(e) => {
            fetching_handle.error();
            return Err(NexusCliError::Any(anyhow!(
                "Failed to fetch Move modules for package {}: {}",
                package_address,
                e
            )));
        }
    };

    // Find the specific module.
    let normalized_module = all_modules.get(module_name).ok_or_else(|| {
        NexusCliError::Any(anyhow!(
            "Module '{}' not found in package '{}'",
            module_name,
            package_address
        ))
    })?;

    let parsing_handle = loading!("Parsing Output enum definition...");

    // Find the Output enum.
    let output_enum = normalized_module
        .enums
        .get(output_enum_name)
        .ok_or_else(|| {
            NexusCliError::Any(anyhow!(
                "Enum '{}' not found in module '{}'",
                output_enum_name,
                module_name
            ))
        })?;

    // Parse the enum variants from the normalized enum.
    let mut schema_map = Map::new();

    // Iterate through each variant in the enum.
    for (variant_name, variant_fields) in &output_enum.variants {
        let mut fields_schema = Map::new();

        // Convert each field in the variant to schema.
        for field in variant_fields {
            let field_schema = convert_move_type_to_schema(&field.type_)?;
            fields_schema.insert(field.name.clone(), field_schema);
        }

        // Create the variant schema.
        let variant_schema = json!({
            "type": "variant",
            "description": format!("{} variant", variant_name),
            "fields": fields_schema
        });

        schema_map.insert(variant_name.to_lowercase(), variant_schema);
    }

    parsing_handle.success();

    let schema_json = Value::Object(schema_map);
    let schema_string = serde_json::to_string(&schema_json)
        .map_err(|e| NexusCliError::Any(anyhow!("Failed to serialize output schema: {}", e)))?;

    Ok(schema_string)
}

/// Allow the user to customize output variant and field descriptions through an interactive prompt.
fn customize_output_variant_and_field_descriptions(
    base_schema: String,
) -> AnyResult<String, NexusCliError> {
    use std::io::{self, Write};

    // Skip interactive prompts in JSON mode.
    if JSON_MODE.load(Ordering::Relaxed) {
        return Ok(base_schema);
    }

    // Parse the schema to modify descriptions.
    let mut schema: Value = serde_json::from_str(&base_schema)
        .map_err(|e| NexusCliError::Any(anyhow::anyhow!("Failed to parse output schema: {}", e)))?;

    let schema_obj = schema
        .as_object_mut()
        .ok_or_else(|| NexusCliError::Any(anyhow::anyhow!("Output schema is not an object")))?;

    // Display header.
    println!(
        "\n{title}",
        title = "Output Schema Descriptions".bold().cyan()
    );
    println!(
        "Customize descriptions for output variants and their fields (press Enter to keep current)"
    );

    // Iterate over each variant.
    for (variant_name, variant_value) in schema_obj.iter_mut() {
        if let Some(variant_obj) = variant_value.as_object_mut() {
            // Customize variant description.
            if let Some(current_desc) = variant_obj.get("description").and_then(|d| d.as_str()) {
                println!(" ");
                println!(
                    "{} Variant {}: {}",
                    "▶".purple().bold(),
                    variant_name.bold(),
                    "variant".blue().bold()
                );
                println!("Current: {}", current_desc.truecolor(150, 150, 150));
                print!("Custom description (Enter to keep): ");
                io::stdout().flush().unwrap();

                let mut new_desc = String::new();
                if io::stdin().read_line(&mut new_desc).is_ok() {
                    let new_desc = new_desc.trim();
                    if !new_desc.is_empty() {
                        variant_obj["description"] = Value::String(new_desc.to_string());
                        println!("{} Updated description", "✓".green().bold());
                    } else {
                        println!("{} Kept current description", "→".truecolor(150, 150, 150));
                    }
                }
            }

            // Customize field descriptions within this variant.
            if let Some(fields_obj) = variant_obj
                .get_mut("fields")
                .and_then(|f| f.as_object_mut())
            {
                if !fields_obj.is_empty() {
                    for (field_name, field_value) in fields_obj.iter_mut() {
                        if let Some(field_obj) = field_value.as_object_mut() {
                            let field_type = field_obj
                                .get("type")
                                .and_then(|v| v.as_str())
                                .unwrap_or("unknown");

                            let current_field_desc = field_obj
                                .get("description")
                                .and_then(|v| v.as_str())
                                .unwrap_or("No description");

                            println!(" ");
                            println!(
                                "{} Field {}: {}",
                                "▶".purple().bold(),
                                field_name.bold(),
                                field_type.blue().bold()
                            );
                            println!("Current: {}", current_field_desc.truecolor(150, 150, 150));
                            print!("Custom description (Enter to keep): ");
                            io::stdout().flush().unwrap();

                            let mut field_input = String::new();
                            if io::stdin().read_line(&mut field_input).is_ok() {
                                let custom_field_desc = field_input.trim();
                                if !custom_field_desc.is_empty() {
                                    field_obj.insert(
                                        "description".to_string(),
                                        Value::String(custom_field_desc.to_string()),
                                    );
                                    println!("{} Updated description", "✓".green().bold());
                                } else {
                                    println!(
                                        "{} Kept current description",
                                        "→".truecolor(150, 150, 150)
                                    );
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    println!(" ");

    // Convert back to JSON string.
    serde_json::to_string(&schema).map_err(|e| {
        NexusCliError::Any(anyhow::anyhow!("Failed to serialize output schema: {}", e))
    })
}
