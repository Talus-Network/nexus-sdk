use {
    crate::{
        command_title,
        display::json_output,
        loading,
        notify_error,
        notify_success,
        prelude::*,
        sui::*,
    },
    nexus_sdk::{
        idents::{primitives, workflow},
        nexus::error::NexusError,
        sui,
        transactions::tool,
    },
    serde::{Deserialize, Serialize},
    serde_json::{json, Map, Value},
    std::{
        collections::HashMap,
        io::{self, Write},
    },
};

/// Register a new onchain tool with automatic schema generation.
/// The input schema is automatically generated by introspecting the Move module's "execute" function.
/// todo: merge this function with the existing `tool_register.rs` function.
/// https://github.com/Talus-Network/nexus/issues/501
pub(crate) async fn register_onchain_tool(
    package: sui::types::Address,
    module: sui::types::Identifier,
    fqn: ToolFqn,
    description: String,
    witness_id: sui::types::Address,
    collateral_coin: sui::types::Address,
    no_save: bool,
    sui_gas_coin: Option<sui::types::Address>,
    sui_gas_budget: u64,
) -> AnyResult<(), NexusCliError> {
    command_title!(
        "Registering Onchain Tool '{fqn}' from package '{package}::{module}'",
        fqn = fqn,
        package = package,
        module = module
    );

    if Some(collateral_coin) == sui_gas_coin {
        return Err(NexusCliError::Any(anyhow!(
            "The coin used for collateral cannot be the same as the gas coin."
        )));
    }

    let nexus_client = get_nexus_client(sui_gas_coin, sui_gas_budget).await?;
    let signer = nexus_client.signer();
    let gas_config = nexus_client.gas_config();
    let address = signer.get_active_address();
    let nexus_objects = &*nexus_client.get_nexus_objects();
    let crawler = nexus_client.crawler();
    let conf = CliConf::load().await.unwrap_or_default();
    let client = build_sui_grpc_client(&conf).await?;

    let collateral_coin = crawler
        .get_object_metadata(collateral_coin)
        .await
        .map(|resp| resp.object_ref())
        .map_err(|e| {
            NexusCliError::Any(anyhow!(
                "Failed to fetch coin object metadata for '{collateral_coin}': {e}"
            ))
        })?;

    // Generate and customize schemas.
    let (input_schema, output_schema) =
        generate_and_customize_schemas(client, package, &module).await?;

    let tx_handle = loading!("Crafting transaction...");

    let mut tx = sui::tx::TransactionBuilder::new();

    if let Err(e) = tool::register_on_chain_for_self(
        &mut tx,
        nexus_objects,
        package,
        module.as_str(),
        &input_schema,
        &output_schema,
        &fqn,
        &description,
        witness_id,
        &collateral_coin,
        address.into(),
    ) {
        tx_handle.error();

        return Err(NexusCliError::Any(e));
    }

    tx_handle.success();

    let mut gas_coin = gas_config.acquire_gas_coin().await;

    tx.set_sender(address);
    tx.set_gas_budget(gas_config.get_budget());
    tx.set_gas_price(nexus_client.get_reference_gas_price());

    tx.add_gas_objects(vec![sui::tx::Input::owned(
        *gas_coin.object_id(),
        gas_coin.version(),
        *gas_coin.digest(),
    )]);

    let tx = tx.finish().map_err(|e| NexusCliError::Any(e.into()))?;

    let signature = signer.sign_tx(&tx).await.map_err(NexusCliError::Nexus)?;

    // Sign and submit the TX.
    let response = match signer.execute_tx(tx, signature, &mut gas_coin).await {
        Ok(response) => {
            gas_config.release_gas_coin(gas_coin).await;

            response
        }
        // If the tool is already registered, we don't want to fail the
        // command.
        Err(NexusError::Wallet(e)) if e.to_string().contains("register_off_chain_tool_") => {
            gas_config.release_gas_coin(gas_coin).await;

            notify_error!(
                "Tool '{fqn}' is already registered.",
                fqn = fqn.to_string().truecolor(100, 100, 100)
            );

            json_output(&json!({
                "tool_fqn": fqn,
                "already_registered": true,
            }))?;

            return Err(NexusCliError::Any(e));
        }
        // Any other error fails the tool registration but continues the
        // loop.
        Err(e) => {
            gas_config.release_gas_coin(gas_coin).await;

            notify_error!(
                "Failed to register tool '{fqn}': {error}",
                fqn = fqn.to_string().truecolor(100, 100, 100),
                error = e
            );

            return Err(NexusCliError::Nexus(e));
        }
    };

    // Extract the OwnerCap<OverTool> object ID.
    let over_tool_id = extract_over_tool_owner_cap(&response.objects, nexus_objects)?;

    // Save the owner caps to the CLI conf.
    if !no_save {
        save_tool_owner_caps(fqn.clone(), over_tool_id).await?;
    }

    json_output(&json!({
        "digest": response.digest,
        "tool_fqn": fqn,
        "package_address": package,
        "module_name": module,
        "witness_id": witness_id.to_string(),
        "description": description,
        "input_schema": input_schema,
        "output_schema": output_schema,
        "owner_cap_over_tool_id": over_tool_id,
        "owner_cap_over_gas_id": null,
        "already_registered": false,
    }))?;

    Ok(())
}

/// Generate input and output schemas and allow user customization.
async fn generate_and_customize_schemas(
    client: Arc<Mutex<sui::grpc::Client>>,
    package_address: sui::types::Address,
    module_name: &str,
) -> AnyResult<(String, String), NexusCliError> {
    // Generate input schema by introspecting the Move module's "execute" function.
    let input_handle = loading!("Auto-generating input schema from Move module...");
    let base_input_schema = match nexus_sdk::onchain_schema_gen::generate_input_schema(
        client.clone(),
        package_address,
        module_name,
        "execute",
    )
    .await
    {
        Ok(schema) => {
            input_handle.success();
            schema
        }
        Err(e) => {
            input_handle.error();
            return Err(NexusCliError::Any(e));
        }
    };

    // Generate output schema by introspecting the Move module's "Output" enum.
    let output_handle = loading!("Auto-generating output schema from Move module...");
    let base_output_schema = match nexus_sdk::onchain_schema_gen::generate_output_schema(
        client,
        package_address,
        module_name,
        "Output",
    )
    .await
    {
        Ok(schema) => {
            output_handle.success();
            schema
        }
        Err(e) => {
            output_handle.error();
            return Err(NexusCliError::Any(e));
        }
    };

    // Allow user to customize parameter descriptions.
    let input_handle = loading!("Customizing input parameter descriptions...");
    let input_schema = match customize_parameter_descriptions(base_input_schema) {
        Ok(schema) => {
            input_handle.success();
            schema
        }
        Err(e) => {
            input_handle.error();
            return Err(e);
        }
    };

    // Allow user to customize output variant and field descriptions.
    let output_handle = loading!("Customizing output variant and field descriptions...");
    let output_schema = match customize_output_variant_and_field_descriptions(base_output_schema) {
        Ok(schema) => {
            output_handle.success();
            schema
        }
        Err(e) => {
            output_handle.error();
            return Err(e);
        }
    };

    Ok((input_schema, output_schema))
}

/// Extract the OwnerCap<OverTool> object ID from the transaction response.
fn extract_over_tool_owner_cap(
    objects: &[sui::types::Object],
    nexus_objects: &NexusObjects,
) -> AnyResult<sui::types::Address, NexusCliError> {
    // Parse the owner cap object IDs from the response.
    let owner_caps = objects
        .iter()
        .filter_map(|obj| {
            let sui::types::ObjectType::Struct(object_type) = obj.object_type() else {
                return None;
            };

            if *object_type.address() == nexus_objects.primitives_pkg_id
                && *object_type.module() == primitives::OwnerCap::CLONEABLE_OWNER_CAP.module
                && *object_type.name() == primitives::OwnerCap::CLONEABLE_OWNER_CAP.name
            {
                Some((obj.object_id(), object_type))
            } else {
                None
            }
        })
        .collect::<Vec<_>>();

    // Find `CloneableOwnerCap<OverTool>` object ID.
    let over_tool = owner_caps.iter().find_map(|(object_id, object_type)| {
        match object_type.type_params().first() {
            Some(sui::types::TypeTag::Struct(what_for))
                if *what_for.module() == workflow::ToolRegistry::OVER_TOOL.module
                    && *what_for.name() == workflow::ToolRegistry::OVER_TOOL.name =>
            {
                Some(object_id)
            }
            _ => None,
        }
    });

    let Some(over_tool_id) = over_tool else {
        return Err(NexusCliError::Any(anyhow!(
            "Could not find the OwnerCap<OverTool> object ID in the transaction response."
        )));
    };

    notify_success!(
        "OwnerCap<OverTool> object ID: {id}",
        id = over_tool_id.to_string().truecolor(100, 100, 100)
    );

    notify_success!("Onchain tools use a different gas model. No OverGas cap was created.");

    Ok(*over_tool_id)
}

/// Save the tool owner caps to the CLI configuration.
async fn save_tool_owner_caps(
    fqn: ToolFqn,
    over_tool_id: sui::types::Address,
) -> AnyResult<(), NexusCliError> {
    let save_handle = loading!("Saving the owner cap to the CLI configuration...");

    let mut conf = CliConf::load().await.unwrap_or_default();

    // For onchain tools, we only have OverTool cap, no OverGas cap.
    conf.tools.insert(
        fqn,
        ToolOwnerCaps {
            over_tool: over_tool_id,
            over_gas: None,
        },
    );

    if let Err(e) = conf.save().await {
        save_handle.error();
        return Err(NexusCliError::Any(e));
    }

    save_handle.success();

    Ok(())
}

/// Represents a single parameter in the input schema.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ParameterSchema {
    #[serde(rename = "type")]
    param_type: String,
    description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    custom_name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    mutable: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    parameter_index: Option<String>,
}

/// Represents an output variant with optional fields.
#[derive(Debug, Clone, Serialize, Deserialize)]
struct OutputVariantSchema {
    #[serde(rename = "type", skip_serializing_if = "Option::is_none")]
    variant_type: Option<String>,
    description: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    fields: Option<Map<String, Value>>,
}

/// Allow the user to customize parameter descriptions interactively.
fn customize_parameter_descriptions_with_reader(
    schema_json: String,
    reader: &mut dyn std::io::BufRead,
) -> AnyResult<String, NexusCliError> {
    // Skip interactive prompts in JSON mode.
    if JSON_MODE.load(Ordering::Relaxed) {
        return Ok(schema_json);
    }

    // Deserialize into a typed map.
    let mut schema: HashMap<String, ParameterSchema> = serde_json::from_str(&schema_json)
        .map_err(|e| NexusCliError::Any(anyhow::anyhow!("Failed to parse schema JSON: {}", e)))?;

    if schema.is_empty() {
        println!(
            "\n{info} No parameters to customize.",
            info = "▶".cyan().bold()
        );
        return Ok(schema_json);
    }

    println!(
        "\n{title}",
        title = "Input Schema Customization".bold().cyan()
    );
    println!(
        "Customize names and descriptions for each input parameter (press Enter to keep current)"
    );

    // Sort parameter keys numerically.
    let mut param_keys: Vec<String> = schema.keys().cloned().collect();
    param_keys.sort_by_key(|k| k.parse::<i32>().unwrap_or(i32::MAX));

    // Customize each parameter.
    for param_key in &param_keys {
        if let Some(param) = schema.get_mut(param_key) {
            customize_parameter(param_key, param, reader)
                .map_err(|e| NexusCliError::Any(anyhow::anyhow!("I/O error: {}", e)))?;
        }
    }

    println!();

    // Convert schema to use custom names as keys.
    let final_schema = build_final_schema(schema)?;

    // Serialize back to JSON.
    serde_json::to_string(&final_schema)
        .map_err(|e| NexusCliError::Any(anyhow::anyhow!("Failed to serialize schema: {}", e)))
}

/// Build the final schema with custom names as keys.
fn build_final_schema(
    schema: HashMap<String, ParameterSchema>,
) -> AnyResult<Map<String, Value>, NexusCliError> {
    let mut final_schema = Map::new();

    for (param_index, mut param) in schema {
        // Use custom name if provided, otherwise use the integer index.
        let key = param.custom_name.take().unwrap_or(param_index);

        // Clear metadata fields before serialization.
        param.parameter_index = None;

        // Convert to JSON value (this automatically excludes None fields).
        let param_value = serde_json::to_value(param).map_err(|e| {
            NexusCliError::Any(anyhow::anyhow!("Failed to serialize parameter: {}", e))
        })?;

        final_schema.insert(key, param_value);
    }

    Ok(final_schema)
}

/// Wrapper function that calls customize_parameter_descriptions_with_reader using stdin.
fn customize_parameter_descriptions(schema_json: String) -> AnyResult<String, NexusCliError> {
    let stdin = io::stdin();
    let mut reader = stdin.lock();
    customize_parameter_descriptions_with_reader(schema_json, &mut reader)
}

/// Allow the user to customize output variant and field descriptions through an interactive prompt.
fn customize_output_variant_and_field_descriptions_with_reader(
    base_schema: String,
    reader: &mut dyn std::io::BufRead,
) -> AnyResult<String, NexusCliError> {
    // Skip interactive prompts in JSON mode.
    if JSON_MODE.load(Ordering::Relaxed) {
        return Ok(base_schema);
    }

    // Deserialize into a typed map.
    let mut schema: HashMap<String, OutputVariantSchema> = serde_json::from_str(&base_schema)
        .map_err(|e| NexusCliError::Any(anyhow::anyhow!("Failed to parse output schema: {}", e)))?;

    // Display header.
    println!(
        "\n{title}",
        title = "Output Schema Descriptions".bold().cyan()
    );
    println!(
        "Customize descriptions for output variants and their fields (press Enter to keep current)"
    );

    // Customize each variant.
    for (variant_name, variant) in schema.iter_mut() {
        customize_output_variant(variant_name, variant, reader)
            .map_err(|e| NexusCliError::Any(anyhow::anyhow!("I/O error: {}", e)))?;
    }

    println!();

    // Serialize back to JSON.
    serde_json::to_string(&schema).map_err(|e| {
        NexusCliError::Any(anyhow::anyhow!("Failed to serialize output schema: {}", e))
    })
}

/// Wrapper function that calls customize_output_variant_and_field_descriptions_with_reader using stdin.
fn customize_output_variant_and_field_descriptions(
    base_schema: String,
) -> AnyResult<String, NexusCliError> {
    let stdin = io::stdin();
    let mut reader = stdin.lock();
    customize_output_variant_and_field_descriptions_with_reader(base_schema, &mut reader)
}

/// Get a field's type and description from JSON value.
fn get_field_info(field_value: &Value) -> (String, String) {
    let field_type = field_value
        .get("type")
        .and_then(|v| v.as_str())
        .unwrap_or("unknown")
        .to_string();
    let description = field_value
        .get("description")
        .and_then(|v| v.as_str())
        .unwrap_or("No description")
        .to_string();
    (field_type, description)
}

/// Update a field's description in the JSON value.
fn update_field_description(field_value: &mut Value, new_description: String) {
    if let Some(obj) = field_value.as_object_mut() {
        obj.insert("description".to_string(), Value::String(new_description));
    }
}

/// Prompt the user for optional input with a default fallback.
fn prompt_optional_input(
    reader: &mut dyn std::io::BufRead,
    prompt: &str,
    current_value: &str,
) -> io::Result<Option<String>> {
    println!("Current: {}", current_value.truecolor(150, 150, 150));
    print!("{}: ", prompt);
    io::stdout().flush()?;

    let mut input = String::new();
    reader.read_line(&mut input)?;
    let trimmed = input.trim();

    if trimmed.is_empty() {
        println!("{} Kept current value", "→".truecolor(150, 150, 150));
        Ok(None)
    } else {
        println!("{} Updated", "✓".green().bold());
        Ok(Some(trimmed.to_string()))
    }
}

/// Customize a single parameter interactively.
fn customize_parameter(
    param_key: &str,
    param: &mut ParameterSchema,
    reader: &mut dyn std::io::BufRead,
) -> io::Result<()> {
    let is_mutable = param.mutable.unwrap_or(false);
    let type_display = if is_mutable {
        format!("mut {}", param.param_type)
    } else {
        param.param_type.clone()
    };

    println!();
    println!(
        "{} Parameter {}: {} {}",
        "▶".purple().bold(),
        param_key.bold(),
        type_display.blue().bold(),
        if is_mutable {
            "(mutable)".yellow()
        } else {
            "".normal()
        }
    );

    // Customize parameter name.
    let default_name = param.custom_name.as_deref().unwrap_or(param_key);
    println!("Current name: {}", default_name.truecolor(150, 150, 150));
    if param.custom_name.is_some() {
        println!("Current custom name: {}", default_name.green());
    }

    if let Some(new_name) = prompt_optional_input(
        reader,
        &format!("Custom name (Enter to keep '{}')", default_name),
        default_name,
    )? {
        param.custom_name = Some(new_name);
    } else if param.custom_name.is_some() {
        // User pressed Enter but had a custom name.
        param.custom_name = None;
    }

    // Customize parameter description.
    if let Some(new_desc) = prompt_optional_input(
        reader,
        "Custom description (Enter to keep)",
        &param.description,
    )? {
        param.description = new_desc;
    }

    Ok(())
}

/// Customize a single output field interactively.
fn customize_output_field(
    field_name: &str,
    field_value: &mut Value,
    reader: &mut dyn std::io::BufRead,
) -> io::Result<()> {
    let (field_type, description) = get_field_info(field_value);

    println!();
    println!(
        "{} Field {}: {}",
        "▶".purple().bold(),
        field_name.bold(),
        field_type.blue().bold()
    );

    if let Some(new_desc) =
        prompt_optional_input(reader, "Custom description (Enter to keep)", &description)?
    {
        update_field_description(field_value, new_desc);
    }

    Ok(())
}

/// Customize a single output variant interactively.
fn customize_output_variant(
    variant_name: &str,
    variant: &mut OutputVariantSchema,
    reader: &mut dyn std::io::BufRead,
) -> io::Result<()> {
    println!();
    println!(
        "{} Variant {}: {}",
        "▶".purple().bold(),
        variant_name.bold(),
        "variant".blue().bold()
    );

    // Customize variant description.
    if let Some(new_desc) = prompt_optional_input(
        reader,
        "Custom description (Enter to keep)",
        &variant.description,
    )? {
        variant.description = new_desc;
    }

    // Customize field descriptions if present.
    if let Some(fields) = &mut variant.fields {
        for (field_name, field_value) in fields.iter_mut() {
            customize_output_field(field_name, field_value, reader)?;
        }
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use {super::*, nexus_sdk::test_utils::sui_mocks, std::sync::atomic::Ordering};

    #[test]
    fn test_build_final_schema_with_custom_names() {
        // Create a schema with integer keys and custom names using typed structs.
        let mut schema = HashMap::new();

        // Parameter 0: u64 with custom name "increment_amount".
        schema.insert(
            "0".to_string(),
            ParameterSchema {
                param_type: "u64".to_string(),
                description: "64-bit unsigned integer".to_string(),
                custom_name: Some("increment_amount".to_string()),
                mutable: None,
                parameter_index: Some("0".to_string()),
            },
        );

        // Parameter 1: object with custom name "counter".
        schema.insert(
            "1".to_string(),
            ParameterSchema {
                param_type: "object".to_string(),
                description: "Counter object reference".to_string(),
                custom_name: Some("counter".to_string()),
                mutable: Some(true),
                parameter_index: Some("1".to_string()),
            },
        );

        // Convert schema.
        let result = build_final_schema(schema).unwrap();

        // Verify custom names are used as keys.
        assert!(result.contains_key("increment_amount"));
        assert!(result.contains_key("counter"));
        assert!(!result.contains_key("0"));
        assert!(!result.contains_key("1"));

        // Verify metadata fields are removed.
        let increment_amount_param = result.get("increment_amount").unwrap().as_object().unwrap();
        assert!(!increment_amount_param.contains_key("custom_name"));
        assert!(!increment_amount_param.contains_key("parameter_index"));

        // Verify type and description are preserved.
        assert_eq!(increment_amount_param.get("type").unwrap(), "u64");
        assert_eq!(
            increment_amount_param.get("description").unwrap(),
            "64-bit unsigned integer"
        );

        // Verify mutable flag is preserved for counter.
        let counter_param = result.get("counter").unwrap().as_object().unwrap();
        assert_eq!(counter_param.get("mutable").unwrap(), true);
        assert!(!counter_param.contains_key("custom_name"));
        assert!(!counter_param.contains_key("parameter_index"));
    }

    #[test]
    fn test_build_final_schema_without_custom_names() {
        // Create a schema with integer keys but no custom names using typed structs.
        let mut schema = HashMap::new();

        // Parameter 0: u64 without custom name.
        schema.insert(
            "0".to_string(),
            ParameterSchema {
                param_type: "u64".to_string(),
                description: "64-bit unsigned integer".to_string(),
                custom_name: None,
                mutable: None,
                parameter_index: None,
            },
        );

        // Parameter 1: object without custom name.
        schema.insert(
            "1".to_string(),
            ParameterSchema {
                param_type: "object".to_string(),
                description: "Object reference".to_string(),
                custom_name: None,
                mutable: Some(true),
                parameter_index: None,
            },
        );

        // Convert schema.
        let result = build_final_schema(schema).unwrap();

        // Verify integer keys are preserved.
        assert!(result.contains_key("0"));
        assert!(result.contains_key("1"));

        // Verify all properties are preserved.
        let param0_result = result.get("0").unwrap().as_object().unwrap();
        assert_eq!(param0_result.get("type").unwrap(), "u64");
        assert_eq!(
            param0_result.get("description").unwrap(),
            "64-bit unsigned integer"
        );

        let param1_result = result.get("1").unwrap().as_object().unwrap();
        assert_eq!(param1_result.get("type").unwrap(), "object");
        assert_eq!(param1_result.get("mutable").unwrap(), true);
    }

    #[test]
    fn test_build_final_schema_mixed() {
        // Create a schema with some custom names and some without using typed structs.
        let mut schema = HashMap::new();

        // Parameter 0: with custom name.
        schema.insert(
            "0".to_string(),
            ParameterSchema {
                param_type: "u64".to_string(),
                description: "Amount parameter".to_string(),
                custom_name: Some("amount".to_string()),
                mutable: None,
                parameter_index: Some("0".to_string()),
            },
        );

        // Parameter 1: without custom name.
        schema.insert(
            "1".to_string(),
            ParameterSchema {
                param_type: "bool".to_string(),
                description: "Flag parameter".to_string(),
                custom_name: None,
                mutable: None,
                parameter_index: None,
            },
        );

        // Parameter 2: with custom name.
        schema.insert(
            "2".to_string(),
            ParameterSchema {
                param_type: "string".to_string(),
                description: "Message parameter".to_string(),
                custom_name: Some("message".to_string()),
                mutable: None,
                parameter_index: Some("2".to_string()),
            },
        );

        // Convert schema.
        let result = build_final_schema(schema).unwrap();

        // Verify mixed keys.
        assert!(result.contains_key("amount")); // Custom name.
        assert!(result.contains_key("1")); // Integer key preserved.
        assert!(result.contains_key("message")); // Custom name.
        assert!(!result.contains_key("0")); // Replaced by custom name.
        assert!(!result.contains_key("2")); // Replaced by custom name.

        // Verify no metadata in results.
        for (_, value) in result.iter() {
            let obj = value.as_object().unwrap();
            assert!(!obj.contains_key("custom_name"));
            assert!(!obj.contains_key("parameter_index"));
        }
    }

    #[test]
    fn test_customize_parameter_descriptions_json_mode() {
        // Set JSON mode to skip interactive prompts.
        JSON_MODE.store(true, Ordering::Relaxed);

        // Input schema based on onchain tool example.
        let input_schema = r#"{
            "0": {
                "type": "object",
                "description": "0x123::onchain_tool::RandomCounter",
                "mutable": true
            },
            "1": {
                "type": "u64",
                "description": "64-bit unsigned integer"
            }
        }"#;

        // Call customize function.
        let result = customize_parameter_descriptions(input_schema.to_string()).unwrap();

        // In JSON mode, schema should be returned unchanged.
        let input_value: Value = serde_json::from_str(input_schema).unwrap();
        let result_value: Value = serde_json::from_str(&result).unwrap();

        assert_eq!(input_value, result_value);

        // Reset JSON mode.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_customize_parameter_descriptions_empty_schema() {
        // Set JSON mode to skip interactive prompts.
        JSON_MODE.store(true, Ordering::Relaxed);

        // Empty schema.
        let input_schema = "{}";

        // Call customize function.
        let result = customize_parameter_descriptions(input_schema.to_string()).unwrap();

        // Should return empty schema unchanged.
        assert_eq!(result, "{}");

        // Reset JSON mode.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_customize_output_variant_and_field_descriptions_json_mode() {
        // Set JSON mode to skip interactive prompts.
        JSON_MODE.store(true, Ordering::Relaxed);

        // Output schema based on onchain tool example.
        let output_schema = r#"{
            "ok": {
                "type": "variant",
                "description": "Ok variant",
                "fields": {
                    "old_count": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    },
                    "new_count": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    },
                    "increment": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    }
                }
            },
            "err": {
                "type": "variant",
                "description": "Err variant",
                "fields": {
                    "reason": {
                        "type": "string",
                        "description": "0x1::ascii::String"
                    }
                }
            },
            "largeincrement": {
                "type": "variant",
                "description": "LargeIncrement variant",
                "fields": {
                    "old_count": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    },
                    "new_count": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    },
                    "increment": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    },
                    "warning": {
                        "type": "string",
                        "description": "0x1::ascii::String"
                    }
                }
            }
        }"#;

        // Call customize function.
        let result =
            customize_output_variant_and_field_descriptions(output_schema.to_string()).unwrap();

        // In JSON mode, schema should be returned unchanged.
        let input_value: Value = serde_json::from_str(output_schema).unwrap();
        let result_value: Value = serde_json::from_str(&result).unwrap();

        assert_eq!(input_value, result_value);

        // Reset JSON mode.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_build_final_schema_preserves_all_fields() {
        // Test that all field types are properly preserved during conversion using typed structs.
        let mut schema = HashMap::new();

        // Parameter with various field types.
        schema.insert(
            "0".to_string(),
            ParameterSchema {
                param_type: "object".to_string(),
                description: "Test object".to_string(),
                custom_name: Some("my_param".to_string()),
                mutable: Some(true),
                parameter_index: Some("0".to_string()),
            },
        );

        // Convert.
        let result = build_final_schema(schema).unwrap();

        // Verify custom name is used and metadata removed.
        assert!(result.contains_key("my_param"));
        let my_param = result.get("my_param").unwrap().as_object().unwrap();

        // Verify all non-metadata fields are preserved.
        assert_eq!(my_param.get("type").unwrap(), "object");
        assert_eq!(my_param.get("description").unwrap(), "Test object");
        assert_eq!(my_param.get("mutable").unwrap(), true);

        // Verify metadata fields are removed.
        assert!(!my_param.contains_key("custom_name"));
        assert!(!my_param.contains_key("parameter_index"));
    }

    #[test]
    fn test_build_final_schema_with_none_custom_name() {
        // Test that None custom_name is treated as no custom name using typed structs.
        let mut schema = HashMap::new();

        schema.insert(
            "0".to_string(),
            ParameterSchema {
                param_type: "u64".to_string(),
                description: "Test param".to_string(),
                custom_name: None,
                mutable: None,
                parameter_index: None,
            },
        );

        // Convert.
        let result = build_final_schema(schema).unwrap();

        // Verify integer key is preserved when custom_name is None.
        assert!(result.contains_key("0"));
        assert_eq!(result.get("0").unwrap()["type"], "u64");
    }

    #[test]
    fn test_customize_parameter_descriptions_with_mock_input() {
        // Ensure JSON_MODE is off for this test.
        JSON_MODE.store(false, Ordering::Relaxed);

        // Create input schema.
        let input_schema = r#"{
            "0": {
                "type": "u64",
                "description": "64-bit unsigned integer"
            }
        }"#;

        // Mock user input: custom name "amount" + enter, then custom description "The amount to use" + enter.
        let mock_input = "amount\nThe amount to use\n";
        let mut reader = std::io::Cursor::new(mock_input.as_bytes());

        // Call the function with mock input.
        let result =
            customize_parameter_descriptions_with_reader(input_schema.to_string(), &mut reader)
                .unwrap();

        // Parse the result.
        let result_value: Value = serde_json::from_str(&result).unwrap();

        // Verify the custom name was applied.
        assert!(result_value.get("amount").is_some());
        assert!(result_value.get("0").is_none());

        // Verify the custom description was applied.
        let amount_param = result_value.get("amount").unwrap();
        assert_eq!(
            amount_param.get("description").unwrap().as_str().unwrap(),
            "The amount to use"
        );
        assert_eq!(amount_param.get("type").unwrap().as_str().unwrap(), "u64");

        // Reset JSON_MODE.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_customize_parameter_descriptions_keep_defaults() {
        // Ensure JSON_MODE is off.
        JSON_MODE.store(false, Ordering::Relaxed);

        // Create input schema.
        let input_schema = r#"{
            "0": {
                "type": "bool",
                "description": "Boolean flag"
            }
        }"#;

        // Mock user input: empty (press enter) for both name and description to keep defaults.
        let mock_input = "\n\n";
        let mut reader = std::io::Cursor::new(mock_input.as_bytes());

        // Call the function.
        let result =
            customize_parameter_descriptions_with_reader(input_schema.to_string(), &mut reader)
                .unwrap();

        // Parse the result.
        let result_value: Value = serde_json::from_str(&result).unwrap();

        // Verify integer key is preserved (no custom name).
        assert!(result_value.get("0").is_some());

        // Verify description is unchanged.
        let param = result_value.get("0").unwrap();
        assert_eq!(
            param.get("description").unwrap().as_str().unwrap(),
            "Boolean flag"
        );

        // Reset JSON_MODE.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_customize_output_with_mock_input() {
        // Ensure JSON_MODE is off.
        JSON_MODE.store(false, Ordering::Relaxed);

        // Create output schema with one variant.
        let output_schema = r#"{
            "ok": {
                "type": "variant",
                "description": "Ok variant",
                "fields": {
                    "count": {
                        "type": "u64",
                        "description": "64-bit unsigned integer"
                    }
                }
            }
        }"#;

        // Mock user input:
        // 1. "Success case\n" for variant description
        // 2. "The final count\n" for field description.
        let mock_input = "Success case\nThe final count\n";
        let mut reader = std::io::Cursor::new(mock_input.as_bytes());

        // Call the function.
        let result = customize_output_variant_and_field_descriptions_with_reader(
            output_schema.to_string(),
            &mut reader,
        )
        .unwrap();

        // Parse the result.
        let result_value: Value = serde_json::from_str(&result).unwrap();

        // Verify variant description was updated.
        let ok_variant = result_value.get("ok").unwrap();
        assert_eq!(
            ok_variant.get("description").unwrap().as_str().unwrap(),
            "Success case"
        );

        // Verify field description was updated.
        let fields = ok_variant.get("fields").unwrap();
        let count_field = fields.get("count").unwrap();
        assert_eq!(
            count_field.get("description").unwrap().as_str().unwrap(),
            "The final count"
        );

        // Reset JSON_MODE.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_customize_output_keep_defaults() {
        // Ensure JSON_MODE is off.
        JSON_MODE.store(false, Ordering::Relaxed);

        // Create output schema.
        let output_schema = r#"{
            "err": {
                "type": "variant",
                "description": "Error variant",
                "fields": {
                    "message": {
                        "type": "string",
                        "description": "Error message"
                    }
                }
            }
        }"#;

        // Mock user input: empty (press enter) for both variant and field to keep defaults.
        let mock_input = "\n\n";
        let mut reader = std::io::Cursor::new(mock_input.as_bytes());

        // Call the function.
        let result = customize_output_variant_and_field_descriptions_with_reader(
            output_schema.to_string(),
            &mut reader,
        )
        .unwrap();

        // Parse the result.
        let result_value: Value = serde_json::from_str(&result).unwrap();

        // Verify descriptions are unchanged.
        let err_variant = result_value.get("err").unwrap();
        assert_eq!(
            err_variant.get("description").unwrap().as_str().unwrap(),
            "Error variant"
        );

        let fields = err_variant.get("fields").unwrap();
        let message_field = fields.get("message").unwrap();
        assert_eq!(
            message_field.get("description").unwrap().as_str().unwrap(),
            "Error message"
        );

        // Reset JSON_MODE.
        JSON_MODE.store(false, Ordering::Relaxed);
    }

    #[test]
    fn test_extract_over_tool_owner_cap_success() {
        let mut rng = rand::thread_rng();
        let nexus_objects = sui_mocks::mock_nexus_objects();

        // Create a mock object vector with an OwnerCap<OverTool>.
        let owner_cap_id = sui::types::Address::generate(&mut rng);
        let owner_address = sui::types::Address::generate(&mut rng);

        let objects = vec![sui::types::Object::new(
            sui::types::ObjectData::Struct(
                sui::types::MoveStruct::new(
                    sui::types::StructTag::new(
                        nexus_objects.primitives_pkg_id,
                        sui::types::Identifier::from_static("owner_cap"),
                        sui::types::Identifier::from_static("CloneableOwnerCap"),
                        vec![],
                    ),
                    true,
                    0,
                    owner_cap_id.to_bcs().unwrap(),
                )
                .unwrap(),
            ),
            sui::types::Owner::Address(owner_address),
            sui::types::Digest::generate(&mut rng),
            1000,
        )];

        // Extract the owner cap.
        let result = extract_over_tool_owner_cap(&objects, &nexus_objects);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), owner_cap_id);
    }

    #[test]
    fn test_extract_over_tool_owner_cap_not_found() {
        let nexus_objects = sui_mocks::mock_nexus_objects();

        // Should fail because no owner cap is found.
        let result = extract_over_tool_owner_cap(&vec![], &nexus_objects);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("Could not find the OwnerCap<OverTool> object ID"));
    }

    #[tokio::test]
    async fn test_generate_and_customize_schemas_integration() {
        use crate::test_utils;

        // Spin up the Sui instance.
        let (_container, rpc_port, faucet_port) =
            test_utils::containers::setup_sui_instance().await;

        // Create a wallet and request some gas tokens.
        let (mut wallet, _) = test_utils::wallet::create_ephemeral_wallet_context(rpc_port)
            .expect("Failed to create a wallet.");
        let sui = wallet.get_client().await.expect("Could not get Sui client");

        let addr = wallet
            .active_address()
            .expect("Failed to get active address.");

        test_utils::faucet::request_tokens(&format!("http://127.0.0.1:{faucet_port}/gas"), addr)
            .await
            .expect("Failed to request tokens from faucet.");

        let gas_coin = test_utils::gas::fetch_gas_coins(&sui, addr)
            .await
            .expect("Failed to fetch gas coin.")
            .into_iter()
            .next()
            .unwrap();

        // Publish test onchain_tool package.
        let response = test_utils::contracts::publish_move_package(
            &mut wallet,
            "../sdk/tests/move/onchain_tool_test",
            gas_coin,
        )
        .await;

        let changes = response
            .object_changes
            .expect("TX response must have object changes");

        let pkg_id = *changes
            .iter()
            .find_map(|c| match c {
                sui::ObjectChange::Published { package_id, .. } => Some(package_id),
                _ => None,
            })
            .expect("Move package must be published");

        // Enable JSON mode to skip interactive prompts.
        JSON_MODE.store(true, Ordering::Relaxed);

        let client = Arc::new(Mutex::new(
            sui::grpc::Client::new(format!("http://127.0.0.1:{rpc_port}"))
                .expect("Failed to create Sui gRPC client"),
        ));

        // Generate and customize schemas.
        let result = generate_and_customize_schemas(
            client,
            pkg_id.to_string().parse().unwrap(),
            "onchain_tool",
        )
        .await;

        // Reset JSON mode.
        JSON_MODE.store(false, Ordering::Relaxed);

        // Should succeed.
        assert!(result.is_ok());
        let (input_schema, output_schema) = result.unwrap();

        // Verify input schema is valid JSON.
        let input_json: serde_json::Value =
            serde_json::from_str(&input_schema).expect("Input schema should be valid JSON");
        assert!(input_json.is_object());

        // Verify output schema is valid JSON.
        let output_json: serde_json::Value =
            serde_json::from_str(&output_schema).expect("Output schema should be valid JSON");
        assert!(output_json.is_object());

        // Verify input schema has expected parameters (counter and increase_with).
        // After skipping ProofOfUID and TxContext, we should have 2 parameters.
        assert_eq!(input_json.as_object().unwrap().len(), 2);

        // Verify output schema has expected variants.
        let output_obj = output_json.as_object().unwrap();
        assert!(output_obj.contains_key("ok") || output_obj.contains_key("err"));
    }

    #[tokio::test]
    async fn test_save_tool_owner_caps_success() {
        let mut rng = rand::thread_rng();
        // Create a test FQN and object ID.
        let fqn = "com.example.testtool@1".parse::<ToolFqn>().unwrap();
        let over_tool_id = sui::types::Address::generate(&mut rng);

        // Call save_tool_owner_caps.
        let result = save_tool_owner_caps(fqn.clone(), over_tool_id).await;

        // Should succeed.
        assert!(result.is_ok());
    }
}
