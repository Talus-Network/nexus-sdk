use {
    js_sys::Promise,
    serde::{Deserialize, Serialize},
    wasm_bindgen::prelude::*,
    wasm_bindgen_futures::future_to_promise,
    web_sys::{console, window, Request, RequestInit, Response},
};

// Sui Event structures
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct SuiEvent {
    pub id: EventID,
    #[serde(rename = "packageId")]
    pub package_id: String,
    #[serde(rename = "transactionModule")]
    pub transaction_module: String,
    pub sender: String,
    #[serde(rename = "type")]
    pub event_type: String,
    #[serde(rename = "parsedJson")]
    pub parsed_json: serde_json::Value,
    pub bcs: String,
    #[serde(
        rename = "timestampMs",
        deserialize_with = "deserialize_optional_string_to_u64"
    )]
    pub timestamp_ms: Option<u64>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct EventID {
    #[serde(rename = "txDigest")]
    pub tx_digest: String,
    #[serde(rename = "eventSeq", deserialize_with = "deserialize_string_to_u64")]
    pub event_seq: u64,
}

// Helper function to deserialize string to u64
fn deserialize_string_to_u64<'de, D>(deserializer: D) -> Result<u64, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let s = String::deserialize(deserializer)?;
    s.parse().map_err(serde::de::Error::custom)
}

// Helper function to deserialize optional string to u64
fn deserialize_optional_string_to_u64<'de, D>(deserializer: D) -> Result<Option<u64>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let opt = Option::<String>::deserialize(deserializer)?;
    match opt {
        Some(s) => s.parse().map(Some).map_err(serde::de::Error::custom),
        None => Ok(None),
    }
}

#[derive(Serialize, Deserialize, Debug)]
pub struct EventPage {
    pub data: Vec<SuiEvent>,
    #[serde(rename = "nextCursor")]
    pub next_cursor: Option<EventID>,
    #[serde(rename = "hasNextPage")]
    pub has_next_page: bool,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SuiRpcRequest {
    pub jsonrpc: String,
    pub id: u64,
    pub method: String,
    pub params: serde_json::Value,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SuiRpcResponse {
    pub jsonrpc: String,
    pub id: u64,
    pub result: Option<EventPage>,
    pub error: Option<serde_json::Value>,
}

/// DAG execution inspection result for JS-side consumption
#[derive(Serialize, Deserialize)]
pub struct DagInspectionResult {
    pub operation_type: String,
    pub execution_id: String,
    pub transaction_digest: String,
    pub events: Vec<ExecutionEvent>,
    pub summary: InspectionSummary,
}

/// Individual execution event matching CLI structure
#[derive(Serialize, Deserialize, Clone)]
pub struct ExecutionEvent {
    pub event_type: String,
    pub vertex: String,
    pub variant: String,
    pub data: serde_json::Value,
    pub is_end_state: bool,
    pub timestamp_ms: Option<u64>,
}

/// Inspection summary
#[derive(Serialize, Deserialize)]
pub struct InspectionSummary {
    pub total_events: usize,
    pub vertices_executed: Vec<String>,
    pub execution_status: String,
    pub has_errors: bool,
}

/// WASM-exported inspection result
#[derive(Serialize, Deserialize)]
#[wasm_bindgen]
pub struct InspectionResult {
    is_success: bool,
    error_message: Option<String>,
    inspection_data: Option<String>,
}

#[wasm_bindgen]
impl InspectionResult {
    #[wasm_bindgen(getter)]
    pub fn is_success(&self) -> bool {
        self.is_success
    }

    #[wasm_bindgen(getter)]
    pub fn error_message(&self) -> Option<String> {
        self.error_message.clone()
    }

    #[wasm_bindgen(getter)]
    pub fn inspection_data(&self) -> Option<String> {
        self.inspection_data.clone()
    }
}

/// âœ… Main function: Inspect DAG execution (async version)
#[wasm_bindgen]
pub fn inspect_dag_execution_async(
    dag_execution_id: &str,
    transaction_digest: &str,
    rpc_url: &str,
    primitives_pkg_id: &str,
) -> Promise {
    let dag_execution_id = dag_execution_id.to_string();
    let transaction_digest = transaction_digest.to_string();
    let rpc_url = rpc_url.to_string();
    let primitives_pkg_id = primitives_pkg_id.to_string();

    future_to_promise(async move {
        let result = inspect_dag_execution_impl(
            &dag_execution_id,
            &transaction_digest,
            &rpc_url,
            &primitives_pkg_id,
        )
        .await;

        match result {
            Ok(inspection_result) => match serde_json::to_string(&inspection_result) {
                Ok(json_str) => {
                    let result = InspectionResult {
                        is_success: true,
                        error_message: None,
                        inspection_data: Some(json_str),
                    };
                    Ok(JsValue::from(
                        serde_wasm_bindgen::to_value(&result).unwrap(),
                    ))
                }
                Err(e) => {
                    let result = InspectionResult {
                        is_success: false,
                        error_message: Some(format!("Serialization error: {}", e)),
                        inspection_data: None,
                    };
                    Ok(JsValue::from(
                        serde_wasm_bindgen::to_value(&result).unwrap(),
                    ))
                }
            },
            Err(e) => {
                let result = InspectionResult {
                    is_success: false,
                    error_message: Some(e),
                    inspection_data: None,
                };
                Ok(JsValue::from(
                    serde_wasm_bindgen::to_value(&result).unwrap(),
                ))
            }
        }
    })
}

/// Implementation of DAG execution inspection using real Sui network queries
async fn inspect_dag_execution_impl(
    dag_execution_id: &str,
    transaction_digest: &str,
    rpc_url: &str,
    primitives_pkg_id: &str,
) -> Result<DagInspectionResult, String> {
    // Validate inputs
    if dag_execution_id.is_empty() || transaction_digest.is_empty() {
        return Err("DAG execution ID and transaction digest are required".to_string());
    }

    console::log_1(&"Starting real DAG execution inspection...".into());

    // Query real events from Sui network
    let events = query_execution_events(transaction_digest, rpc_url, primitives_pkg_id).await?;

    // Parse events into our format
    let execution_events = parse_sui_events_to_execution_events(events, dag_execution_id)?;

    let inspection_result = DagInspectionResult {
        operation_type: "dag_execution_inspection".to_string(),
        execution_id: dag_execution_id.to_string(),
        transaction_digest: transaction_digest.to_string(),
        events: execution_events.clone(),
        summary: InspectionSummary {
            total_events: execution_events.len(),
            vertices_executed: extract_vertices_from_events(&execution_events),
            execution_status: determine_execution_status(&execution_events),
            has_errors: check_for_errors(&execution_events),
        },
    };

    Ok(inspection_result)
}

/// Query events from Sui network using RPC
async fn query_execution_events(
    transaction_digest: &str,
    rpc_url: &str,
    primitives_pkg_id: &str,
) -> Result<Vec<SuiEvent>, String> {
    let window = window().ok_or("No window object available")?;

    // Create RPC request
    let rpc_request = SuiRpcRequest {
        jsonrpc: "2.0".to_string(),
        id: 1,
        method: "suix_queryEvents".to_string(),
        params: serde_json::json!([
            {
                "MoveEventModule": {
                    "package": primitives_pkg_id,
                    "module": "event"
                }
            },
            {
                "txDigest": transaction_digest,
                "eventSeq": "0"
            },
            null,
            false
        ]),
    };

    // Serialize request
    let request_body = serde_json::to_string(&rpc_request)
        .map_err(|e| format!("Failed to serialize RPC request: {}", e))?;

    console::log_1(&format!("Querying events with RPC request: {}", request_body).into());

    // Create fetch request
    let mut request_init = RequestInit::new();
    request_init.method("POST");
    request_init.body(Some(&JsValue::from_str(&request_body)));

    let mut headers = js_sys::Object::new();
    js_sys::Reflect::set(
        &headers,
        &JsValue::from_str("Content-Type"),
        &JsValue::from_str("application/json"),
    )
    .map_err(|_| "Failed to set headers")?;
    request_init.headers(&headers);

    let request = Request::new_with_str_and_init(rpc_url, &request_init)
        .map_err(|_| "Failed to create request")?;

    // Make fetch request
    let response_promise = window.fetch_with_request(&request);
    let response = wasm_bindgen_futures::JsFuture::from(response_promise)
        .await
        .map_err(|_| "Fetch request failed")?;

    let response: Response = response.dyn_into().map_err(|_| "Failed to cast response")?;

    // Get response text
    let text_promise = response.text().map_err(|_| "Failed to get response text")?;
    let text = wasm_bindgen_futures::JsFuture::from(text_promise)
        .await
        .map_err(|_| "Failed to await response text")?;

    let response_text = text.as_string().ok_or("Response is not a string")?;

    console::log_1(&format!("RPC Response: {}", response_text).into());

    // Parse RPC response
    let rpc_response: SuiRpcResponse = serde_json::from_str(&response_text).map_err(|e| {
        console::log_1(&format!("RPC Parse Error: {}", e).into());
        console::log_1(&format!("Response Text: {}", response_text).into());
        format!(
            "Failed to parse RPC response: {}. Response: {}",
            e, response_text
        )
    })?;

    if let Some(error) = rpc_response.error {
        return Err(format!("RPC error: {}", error));
    }

    let event_page = rpc_response.result.ok_or("No result in RPC response")?;

    Ok(event_page.data)
}

/// Parse Sui events into our ExecutionEvent format
fn parse_sui_events_to_execution_events(
    sui_events: Vec<SuiEvent>,
    dag_execution_id: &str,
) -> Result<Vec<ExecutionEvent>, String> {
    let mut execution_events = Vec::new();

    for sui_event in sui_events {
        // Parse the event based on its structure
        if let Some(event_wrapper) = sui_event.parsed_json.get("event") {
            // Try to determine event type from the Sui event structure
            let event_type = determine_event_type(&event_wrapper);

            // Extract vertex and variant information
            let (vertex, variant, data, is_end_state) =
                extract_event_details(&event_wrapper, &event_type)?;

            // Only include events related to our DAG execution
            if is_relevant_event(&event_wrapper, dag_execution_id) {
                execution_events.push(ExecutionEvent {
                    event_type,
                    vertex,
                    variant,
                    data,
                    is_end_state,
                    timestamp_ms: sui_event.timestamp_ms,
                });
            }
        }
    }

    Ok(execution_events)
}

/// Determine event type from Sui event structure
fn determine_event_type(event_data: &serde_json::Value) -> String {
    // Look at the structure to determine event type
    if event_data.get("next_vertex").is_some() {
        "WalkAdvanced".to_string()
    } else if event_data.get("has_any_walk_failed").is_some() {
        "ExecutionFinished".to_string()
    } else if event_data.get("execution").is_some() {
        // Check for other event patterns
        "EndStateReached".to_string()
    } else {
        "Unknown".to_string()
    }
}

/// Extract event details from Sui event
fn extract_event_details(
    event_data: &serde_json::Value,
    event_type: &str,
) -> Result<(String, String, serde_json::Value, bool), String> {
    match event_type {
        "WalkAdvanced" => {
            let vertex = event_data
                .get("next_vertex")
                .and_then(|v| v.get("name"))
                .and_then(|n| n.as_str())
                .unwrap_or("")
                .to_string();

            let variant = "ok".to_string(); // Default variant

            // Parse walk_index from string to number
            let walk_index = event_data
                .get("walk_index")
                .and_then(|v| v.as_str())
                .and_then(|s| s.parse::<u64>().ok())
                .unwrap_or(0);

            let data = serde_json::json!({
                "walk_index": walk_index,
                "worksheet_from_type": event_data.get("worksheet_from_type").cloned().unwrap_or(serde_json::Value::Null),
                "dag": event_data.get("dag").cloned().unwrap_or(serde_json::Value::Null),
                "execution": event_data.get("execution").cloned().unwrap_or(serde_json::Value::Null),
                "evaluations": event_data.get("evaluations").cloned().unwrap_or(serde_json::Value::Null)
            });

            Ok((vertex, variant, data, false))
        }
        "ExecutionFinished" => {
            let has_failed = event_data
                .get("has_any_walk_failed")
                .and_then(|v| v.as_bool())
                .unwrap_or(false);

            let variant = if has_failed { "failed" } else { "success" }.to_string();
            let data = serde_json::json!({
                "has_any_walk_failed": has_failed,
                "execution": event_data.get("execution").cloned().unwrap_or(serde_json::Value::Null)
            });

            Ok(("".to_string(), variant, data, true))
        }
        _ => {
            // Generic event parsing
            let vertex = "unknown".to_string();
            let variant = "unknown".to_string();
            let data = event_data.clone();

            Ok((vertex, variant, data, false))
        }
    }
}

/// Check if event is relevant to our DAG execution
fn is_relevant_event(event_data: &serde_json::Value, dag_execution_id: &str) -> bool {
    if let Some(execution_id) = event_data.get("execution") {
        if let Some(id_str) = execution_id.as_str() {
            return id_str == dag_execution_id;
        }
    }

    // If no execution ID in event, include it (might be a general event)
    true
}

/// Extract unique vertices from events
fn extract_vertices_from_events(events: &[ExecutionEvent]) -> Vec<String> {
    let mut vertices = vec![];
    for event in events {
        if !event.vertex.is_empty() && !vertices.contains(&event.vertex) {
            vertices.push(event.vertex.clone());
        }
    }
    vertices
}

/// Determine execution status from events
fn determine_execution_status(events: &[ExecutionEvent]) -> String {
    for event in events {
        if event.event_type == "ExecutionFinished" {
            if let Some(has_failed) = event.data.get("has_any_walk_failed") {
                if has_failed.as_bool().unwrap_or(false) {
                    return "failed".to_string();
                }
            }
            return "success".to_string();
        }
    }
    "running".to_string()
}

/// Check for errors in events
fn check_for_errors(events: &[ExecutionEvent]) -> bool {
    for event in events {
        if event.event_type == "ExecutionFinished" {
            if let Some(has_failed) = event.data.get("has_any_walk_failed") {
                return has_failed.as_bool().unwrap_or(false);
            }
        }
        if event.variant == "error" || event.variant == "failed" {
            return true;
        }
    }
    false
}

/// âœ… Synchronous version for backwards compatibility
#[wasm_bindgen]
pub fn inspect_dag_execution(dag_execution_id: &str, transaction_digest: &str) -> InspectionResult {
    // For sync version, return error directing to async version
    InspectionResult {
        is_success: false,
        error_message: Some(
            "Please use the async version: inspect_dag_execution_async()".to_string(),
        ),
        inspection_data: None,
    }
}

/// âœ… Helper function: Check if execution is complete
#[wasm_bindgen]
pub fn check_execution_status(
    dag_execution_id: &str,
    transaction_digest: &str,
) -> InspectionResult {
    if dag_execution_id.is_empty() || transaction_digest.is_empty() {
        return InspectionResult {
            is_success: false,
            error_message: Some("DAG execution ID and transaction digest are required".to_string()),
            inspection_data: None,
        };
    }

    let status_result = serde_json::json!({
        "execution_id": dag_execution_id,
        "transaction_digest": transaction_digest,
        "status": "Use async version for real status",
        "is_successful": true,
        "completion_time": "2024-01-24T10:30:00Z"
    });

    match serde_json::to_string(&status_result) {
        Ok(json_data) => InspectionResult {
            is_success: true,
            error_message: None,
            inspection_data: Some(json_data),
        },
        Err(e) => InspectionResult {
            is_success: false,
            error_message: Some(format!("Serialization error: {}", e)),
            inspection_data: None,
        },
    }
}
